"""
Tools for article processing: markdown cleaning and summarization.
"""
import sys
from pathlib import Path
# Add project root to path
project_root = Path(__file__).parent
sys.path.insert(0, str(project_root))

import os
import smtplib
from pathlib import Path
from datetime import datetime
from typing import List
from app.database.db_manager import DatabaseManager
from email.mime.text import MIMEText
from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI
from openai import OpenAI
from app.agent.schemas import ArticleSummary
from app.agent.prompts import MARKDOWN_CLEANER_PROMPT, ARTICLE_SUMMARIZER_PROMPT, ARTICLE_SUMMARIZER_PROMPT_WITH_WEB_SEARCH, get_newsletter_prompt
from dotenv import load_dotenv
from jinja2 import Template
load_dotenv()

def clean_markdown(content: str, llm: ChatOpenAI) -> str:
    """
    Clean markdown content by removing navigation, ads, and keeping only article body.
    
    Args:
        content: Raw markdown content to clean
        llm: ChatOpenAI instance to use for cleaning
        
    Returns:
        Cleaned markdown content
    """
    if not content:
        return ""
    
    prompt = ChatPromptTemplate.from_template(MARKDOWN_CLEANER_PROMPT)
    chain = prompt | llm
    
    try:
        response = chain.invoke({"content": content})
        return response.content.strip()
    except Exception as e:
        print(f"Error cleaning markdown: {e}")
        return content


def summarize_article(title: str, content: str, llm: ChatOpenAI) -> ArticleSummary:
    """
    Generate structured summary of an article for non-expert readers.
    
    Args:
        title: Article title
        content: Article content (should be cleaned markdown)
        llm: ChatOpenAI instance to use for summarization
        
    Returns:
        ArticleSummary object with structured summary
    """
    if not content:
        return ArticleSummary(
            overview="No content available",
            key_points=[],
            why_it_matters="Unable to summarize",
            simple_explanation="No content available to summarize."
        )
    
    # Get prompt based on current language setting
    prompt_template = get_newsletter_prompt()
    prompt = ChatPromptTemplate.from_template(prompt_template)
    
    # Use structured output with Pydantic
    structured_llm = llm.with_structured_output(ArticleSummary)
    chain = prompt | structured_llm
    
    try:
        summary = chain.invoke({"title": title, "content": content})
        return summary
    except Exception as e:
        print(f"Error summarizing: {e}")
        return ArticleSummary(
            overview="Summary generation failed",
            key_points=["Error occurred during summarization"],
            why_it_matters="Unable to determine",
            simple_explanation=f"Error: {str(e)}"
        )

def summarize_article_with_web_search(title: str, url: str, date: str,llm: OpenAI) -> ArticleSummary:
    """
    Generate structured summary of an article for non-expert readers.
    
    Args:
        title: Article title
        URL: Article URL
        llm: ChatOpenAI instance to use for summarization
        
    Returns:
        ArticleSummary object with structured summary
    """
    title = f"Article Title: {title}"
    url = f"Article URL: {url}"

    response = llm.responses.create(
        model=os.getenv("WEB_SEARCH_MODEL"),
        reasoning={"effort": "low"},
        tools=[
            {
                "type": "web_search",
            }
        ],
        instructions=ARTICLE_SUMMARIZER_PROMPT_WITH_WEB_SEARCH.format(title=title, url=url, date=date),
        input=title,
        tool_choice="required",
        include=["web_search_call.action.sources"]
    )
    return response.output_text


def send_email_with_content(items: List[dict], recipients: List[str]) -> bool:
    """
    Send an email with content generated by an agent.
    
    The subject and sender are retrieved from environment variables:
    - EMAIL_SUBJECT: Email subject (required)
    - EMAIL_SENDER: Sender email address (required)
    - EMAIL_PASSWORD: Gmail app password (required, from .env file)
    
    Args:
        items: List of dictionaries with news items. Each dict should have:
            - category: str (same as source)
            - title: str (article title)
            - summary: str (article summary/description)
            - source: str (source name)
            - link: str (article URL)
        recipients: List of recipient email addresses
        
    Returns:
        True if email was sent successfully, False otherwise
        
    Raises:
        ValueError: If required environment variables are not set
    """
    # Get configuration from environment variables
    subject_base = os.getenv("EMAIL_SUBJECT")
    subject = f"{subject_base} {datetime.now().strftime('%Y-%m-%d')}" if subject_base else None
    sender = os.getenv("EMAIL_SENDER")
    password = os.getenv("EMAIL_PASSWORD")
    
    # Validate required environment variables
    if not subject:
        raise ValueError("EMAIL_SUBJECT environment variable is not set")
    if not sender:
        raise ValueError("EMAIL_SENDER environment variable is not set")
    if not password:
        raise ValueError("EMAIL_PASSWORD environment variable is not set in .env file")
    
    # Validate recipients
    if not recipients:
        raise ValueError("At least one recipient email address is required")
    
    if not isinstance(recipients, list):
        raise ValueError("Recipients must be a list of email addresses")
    
    # Validate items
    if not items:
        raise ValueError("At least one news item is required")
    
    if not isinstance(items, list):
        raise ValueError("Items must be a list of dictionaries")
    
    # Validate item structure
    required_keys = ['category', 'title', 'summary', 'source']
    for i, item in enumerate(items):
        if not isinstance(item, dict):
            raise ValueError(f"Item at index {i} must be a dictionary")
        for key in required_keys:
            if key not in item:
                raise ValueError(f"Item at index {i} is missing required key: {key}")
    
    try:
        # Get the template path
        template_path = Path(__file__).parent.parent / 'templates' / 'template.html'
        
        if not template_path.exists():
            raise FileNotFoundError(f"Template not found at {template_path}")
        
        # Read and compile the template
        with open(template_path, 'r', encoding='utf-8') as f:
            template_content = f.read()
        
        template = Template(template_content)
        
        # Render the template with DATE and news_items
        html_msg = template.render(
            DATE=datetime.now().strftime("%A, %B %d, %Y"),
            news_items=items
        )
        
        # Create email message
        msg = MIMEText(html_msg, 'html')
        msg['Subject'] = subject
        msg['From'] = sender
        msg['To'] = ', '.join(recipients)
        
        # Send email using Gmail SMTP
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp_server:
            smtp_server.login(sender, password)
            smtp_server.sendmail(sender, recipients, msg.as_string())
        
        print(f"✓ Email sent successfully to {len(recipients)} recipient(s)")
        return True
        
    except FileNotFoundError as e:
        print(f"✗ Template file not found: {e}")
        return False
    except smtplib.SMTPAuthenticationError as e:
        print(f"✗ Email authentication failed: {e}")
        print("Please check your EMAIL_SENDER and EMAIL_PASSWORD in .env file")
        return False
    except smtplib.SMTPException as e:
        print(f"✗ Email sending failed: {e}")
        return False
    except Exception as e:
        print(f"✗ Unexpected error sending email: {e}")
        import traceback
        traceback.print_exc()
        return False


def aggregate_today_news() -> List[dict]:
    """
    Aggregate all news articles from today and format them for email.
    
    Returns:
        List of dictionaries in the format:
        {
            "category": str,  # Same as source
            "title": str,
            "summary": str,
            "source": str,
            "link": str
        }
    """
    db_manager = DatabaseManager()
    return db_manager.aggregate_today_news()


def send_daily_news_email(recipients: List[str]) -> bool:
    """
    Aggregate today's news from database and send via email.
    
    Args:
        recipients: List of recipient email addresses
        
    Returns:
        True if email was sent successfully, False otherwise
    """
    print("\n[Email Aggregator] Collecting today's news...")
    
    # Aggregate today's news
    news_items = aggregate_today_news()
    
    if not news_items:
        print("✗ No news items found for today")
        return False
    
    print(f"✓ Found {len(news_items)} news items from today")
    
    # Send email
    return send_email_with_content(news_items, recipients)